package Vend::CIDR;

use strict;
use warnings;

use base qw/Exporter/;

our @EXPORT_OK = qw/cidr2regex normalize_ip resembles_ip resembles_cidr/;

sub cidr2regex {
    local $_ = shift;

    /^(.+)\/\d+/;
    return unless resembles_ip($1);
    return cidr2regex_ip4($_) if /\./;
    return cidr2regex_ip6($_);
}

sub cidr2regex_ip4 {
    local $_ = shift;

    return unless /([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\/([0-9]{1,2})/;

    my $map = {
        # 255
        '0' => {
            '0' => '[0-9]{1,3}',
        },
        # 128
        '1' => {
            '0' => '([0-9]{0,1}[0-9]|1[0-1][0-9]|12[0-7])',
            '128' => '(12[8-9]|1[3-9][0-9]|2[0-5][0-9])',
        },
        # 64
        '2' => {
            '0' => '([0-5]{0,1}[0-9]|6[0-3])',
            '64' => '(6[4-9]|[7-9][0-9]|1[0-1][0-9]|12[0-7])',
            '128' => '(12[8-9]|1[3-8][0-9]|19[0-1])',
            '192' => '(19[2-9]|2[0-5][0-9])',
        },
        # 32
        '3' => {
            '0' => '([0-2]{0,1}[0-9]|3[0-1])',
            '32' => '(3[2-9]|[4-5][0-9]|6[0-3])',
            '64' => '(6[4-9]|[7-8][0-9]|9[0-5])',
            '96' => '(9[6-9]|1[0-1][0-9]|12[0-7])',
            '128' => '(12[8-9]|1[3-5][0-9])',
            '160' => '(1[6-8][0-9]|19[0-1])',
            '192' => '(19[2-9]|2[0-1][0-9]|22[0-3])',
            '224' => '(22[4-9]|2[3-5][0-9])',
        },
        # 16
        '4' => {
            '0' => '([0-9]|1[0-5])',
            '16' => '(1[6-9]|2[0-9]|3[0-1])',
            '32' => '(3[2-9]|4[0-7])',
            '48' => '(4[8-9]|5[0-9]|6[0-3])',
            '64' => '(6[4-9]|7[0-9])',
            '80' => '(8[0-9]|9[0-5])',
            '96' => '(9[6-9]|10[0-9]|11[0-1])',
            '112' => '(11[2-9]|12[0-7])',
            '128' => '(12[8-9]|13[0-9]|14[0-3])',
            '144' => '(14[4-9]|15[0-9])',
            '160' => '(16[0-9]|17[0-5])',
            '176' => '(17[6-9]|18[0-9]|19[0-1])',
            '192' => '(19[2-9]|20[0-7])',
            '208' => '(20[8-9]|21[0-9]|22[0-3])',
            '224' => '(22[4-9]|23[0-9])',
            '240' => '2[4-5][0-9]',
        },
        # 8
        '5' => {
            '0' => '[0-7]',
            '8' => '([8-9]|1[0-5])',
            '16' => '(1[6-9]|2[0-3])',
            '24' => '(2[4-9]|3[0-1])',
            '32' => '3[2-9]',
            '40' => '4[0-7]',
            '48' => '(4[8-9]|5[0-5])',
            '56' => '(5[6-9]|6[0-3])',
            '64' => '(6[4-9]|7[0-1])',
            '72' => '7[2-9]',
            '80' => '8[0-7]',
            '88' => '(8[8-9]|9[0-5])',
            '96' => '(9[6-9]|10[0-3])',
            '104' => '(10[4-9]|11[0-1])',
            '112' => '11[2-9]',
            '120' => '12[0-7]',
            '128' => '(12[8-9]|13[0-5])',
            '136' => '(13[6-9]|14[0-3])',
            '144' => '(14[4-9]|15[0-1])',
            '152' => '15[2-9]',
            '160' => '16[0-7]',
            '168' => '(16[8-9]|17[0-5])',
            '176' => '(17[6-9]|18[0-3])',
            '184' => '(18[4-9]|19[0-1])',
            '192' => '19[2-9]',
            '200' => '20[0-7]',
            '208' => '(20[8-9]|21[0-5])',
            '216' => '(21[6-9]|22[0-3])',
            '224' => '(22[4-9]|23[0-1])',
            '232' => '23[2-9]',
            '240' => '24[0-7]',
            '248' => '(24[8-9]|25[0-5])',
        },
        # 4
        '6' => {
            '0' => '[0-3]',
            '4' => '[4-7]',
            '8' => '([8-9]|1[0-1])',
            '12' => '1[2-5]',
            '16' => '1[6-9]',
            '20' => '2[0-3]',
            '24' => '2[4-7]',
            '28' => '(2[8-9]|3[0-1])',
            '32' => '3[2-5]',
            '36' => '3[6-9]',
            '40' => '4[0-3]',
            '44' => '4[4-7]',
            '48' => '(4[8-9]|5[0-1])',
            '52' => '5[2-5]',
            '56' => '5[6-9]',
            '60' => '6[0-3]',
            '64' => '6[4-7]',
            '68' => '(6[8-9]|7[0-1])',
            '72' => '7[2-5]',
            '76' => '7[6-9]',
            '80' => '8[0-3]',
            '84' => '8[4-7]',
            '88' => '(8[8-9]|9[0-1])',
            '92' => '9[2-5]',
            '96' => '9[6-9]',
            '100' => '10[0-3]',
            '104' => '10[4-7]',
            '108' => '(10[8-9]|11[0-1])',
            '112' => '11[2-5]',
            '116' => '11[6-9]',
            '120' => '12[0-3]',
            '124' => '12[4-7]',
            '128' => '(12[8-9]|13[0-1])',
            '132' => '13[2-5]',
            '136' => '13[6-9]',
            '140' => '14[0-3]',
            '144' => '14[4-7]',
            '148' => '(14[8-9]|15[0-1])',
            '152' => '15[2-5]',
            '156' => '15[6-9]',
            '160' => '16[0-3]',
            '164' => '16[4-7]',
            '168' => '(16[8-9]|17[0-1])',
            '172' => '17[2-5]',
            '176' => '17[6-9]',
            '180' => '18[0-3]',
            '184' => '18[4-7]',
            '188' => '(18[8-9]|19[0-1])',
            '192' => '19[2-5]',
            '196' => '19[6-9]',
            '200' => '20[0-3]',
            '204' => '20[4-7]',
            '208' => '(20[8-9]|21[0-1])',
            '212' => '21[2-5]',
            '216' => '21[6-9]',
            '220' => '22[0-3]',
            '224' => '22[4-7]',
            '228' => '(22[8-9]|23[0-1])',
            '232' => '23[2-5]',
            '236' => '23[6-9]',
            '240' => '24[0-3]',
            '244' => '24[4-7]',
            '248' => '(24[8-9]|25[0-1])',
            '252' => '25[2-5]',
        },
    };

	my ($bip, $len);
    my $any = $map->{0}->{0};

    my $act = {
        '0' => sub {
            return $any . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '1' => sub {
            $bip = (int($1) >> 7) << 7;
            return $map->{1}->{$bip} . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '2' => sub {
            $bip = (int($1) >> 6) << 6;
            return $map->{2}->{$bip} . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '3' => sub {
            $bip = (int($1) >> 5) << 5;
            return $map->{3}->{$bip} . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '4' => sub {
            $bip = (int($1) >> 4) << 4;
            return $map->{4}->{$bip} . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '5' => sub {
            $bip = (int($1) >> 3) << 3;
            return $map->{5}->{$bip} . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '6' => sub {
            $bip = (int($1) >> 2) << 2;
            return $map->{6}->{$bip} . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '7' => sub {
            $bip = (int($1) >> 1) << 1;
            $len = length $bip;

            return
              $len == 2 ? substr($bip,0,1) . '[' . substr($bip,1) . '-' . substr($bip+1,1) . ']' . '\\.' . $any . '\\.' . $any . '\\.' . $any :
              $len == 3 ? substr($bip,0,2) . '[' . substr($bip,2) . '-' . substr($bip+1,2) . ']' . '\\.' . $any . '\\.' . $any . '\\.' . $any :
              '[' . $bip . '-' . ($bip+1) . ']' . '\\.' . $any . '\\.' . $any . '\\.' . $any;
		},
        '8' => sub {
            return $1 . '\\.' . $any . '\\.' . $any . '\\.' . $any
        },
        '9' => sub {
            $bip = (int($2)>> 7) << 7;
            return $1 . '\\.' . $map->{1}->{$bip} . '\\.' . $any . '\\.' . $any
        },
        '10' => sub {
            $bip = (int($2)>> 6) << 6;
            return $1 . '\\.' . $map->{2}->{$bip} . '\\.' . $any . '\\.' . $any
        },
        '11' => sub {
            $bip = (int($2)>> 5) << 5;
            return $1 . '\\.' . $map->{3}->{$bip} . '\\.' . $any . '\\.' . $any
        },
        '12' => sub {
            $bip = (int($2)>> 4) << 4;
            return $1 . '\\.' . $map->{4}->{$bip} . '\\.' . $any . '\\.' . $any
        },
        '13' => sub {
            $bip = (int($2)>> 3) << 3;
            return $1 . '\\.' . $map->{5}->{$bip} . '\\.' . $any . '\\.' . $any
        },
        '14' => sub {
            $bip = (int($2)>> 2) << 2;
            return $1 . '\\.' . $map->{6}->{$bip} . '\\.' . $any . '\\.' . $any
        },
        '15' => sub {
            $bip = (int($2) >> 1) << 1;
            $len = length $bip;

            return
              $len == 2 ? $1 . '\\.' . substr($bip,0,1) . '[' . substr($bip,1) . '-' . substr($bip+1,1) . ']' . '\\.' . $any . '\\.' . $any :
              $len == 3 ? $1 . '\\.' . substr($bip,0,2) . '[' . substr($bip,2) . '-' . substr($bip+1,2) . ']' . '\\.' . $any . '\\.' . $any :
              $1 . '\\.' . '[' . $bip . '-' . ($bip+1) . ']' . '\\.' . $any . '\\.' . $any;
		},
        '16' => sub {
            return $1 . '\\.' . $2 . '\\.' . $any . '\\.' . $any
        },
        '17' => sub {
            $bip = (int($3)>> 7) << 7;
            return $1 . '\\.' . $2 . '\\.' . $map->{1}->{$bip} . '\\.' . $any
        },
        '18' => sub {
            $bip = (int($3)>> 6) << 6;
            return $1 . '\\.' . $2 . '\\.' . $map->{2}->{$bip} . '\\.' . $any
        },
        '19' => sub {
            $bip = (int($3)>> 5) << 5;
            return $1 . '\\.' . $2 . '\\.' . $map->{3}->{$bip} . '\\.' . $any
        },
        '20' => sub {
            $bip = (int($3)>> 4) << 4;
            return $1 . '\\.' . $2 . '\\.' . $map->{4}->{$bip} . '\\.' . $any
        },
        '21' => sub {
            $bip = (int($3)>> 3) << 3;
            return $1 . '\\.' . $2 . '\\.' . $map->{5}->{$bip} . '\\.' . $any
        },
        '22' => sub {
            $bip = (int($3)>> 2) << 2;
            return $1 . '\\.' . $2 . '\\.' . $map->{6}->{$bip} . '\\.' . $any
        },
        '23' => sub {
            $bip = (int($3) >> 1) << 1;
            $len = length $bip;

            return
              $len == 2 ? $1 . '\\.' . $2 . '\\.' . substr($bip,0,1) . '[' . substr($bip,1) . '-' . substr($bip+1,1) . ']' . '\\.' . $any :
              $len == 3 ? $1 . '\\.' . $2 . '\\.' . substr($bip,0,2) . '[' . substr($bip,2) . '-' . substr($bip+1,2) . ']' . '\\.' . $any :
              $1 . '\\.' . $2 . '\\.' . '[' . $bip . '-' . ($bip+1) . ']' . '\\.' . $any;
		},
        '24' => sub {
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $any
        },
        '25' => sub {
            $bip = (int($4)>> 7) << 7;
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $map->{1}->{$bip}
        },
        '26' => sub {
            $bip = (int($4)>> 6) << 6;
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $map->{2}->{$bip}
        },
        '27' => sub {
            $bip = (int($4)>> 5) << 5;
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $map->{3}->{$bip}
        },
        '28' => sub {
            $bip = (int($4)>> 4) << 4;
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $map->{4}->{$bip}
        },
        '29' => sub {
            $bip = (int($4)>> 3) << 3;
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $map->{5}->{$bip}
        },
        '30' => sub {
            $bip = (int($4)>> 2) << 2;
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $map->{6}->{$bip}
        },
        '31' => sub {
            $bip = (int($4) >> 1) << 1;
            $len = length $bip;

            return
              $len == 2 ? $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . substr($bip,0,1) . '[' . substr($bip,1) . '-' . substr($bip+1,1) . ']' :
              $len == 3 ? $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . substr($bip,0,2) . '[' . substr($bip,2) . '-' . substr($bip+1,2) . ']' :
              $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . '[' . $bip . '-' . ($bip+1) . ']' ;
		},
        '32' => sub {
            return $1 . '\\.' . $2 . '\\.' . $3 . '\\.' . $4
        },
    };

    return $act->{$5}->();
}

sub cidr2regex_ip6 {
    local $_ = shift;

    return unless /^([:a-f0-9]+)\/(\d+)$/i;

    my $masklen = $2;

    return unless $masklen <= 128;
    return unless my $norm = normalize_ip6($1);

    return $norm if $masklen == 128; # fixed IP
    return '.*' if $masklen == 0;    # open mask

    # nybble count
    my $nyblen = $masklen >> 2;
    # remainder to determine regex
    my $nybmod = $masklen & 0x3;
    my $ncolons = $nyblen >> 2;

    my $pat_lkup = [
        [""],
        ["[0-7]","[89a-f]"],
        ["[0-3]","[4-7]","[89ab]","[c-f]"],
        ["[01]","[23]","[45]","[67]","[89]","[ab]","[cd]","[ef]"],
    ];
    my $chr = hex(substr($norm, $ncolons + $nyblen, 1));
    my $pat = $pat_lkup->[$nybmod]->[$chr >> (4-$nybmod)];
    return sprintf '%s%s.*', substr($norm, 0, $ncolons + $nyblen), $pat;
}

sub normalize_ip {
    local $_ = shift;

    return unless resembles_ip($_);
    return $_ if /^\d+\.\d+\.\d+\.\d+$/;
    return normalize_ip6($_);
}

sub normalize_ip6 {
    my ($src_addr) = @_;

    if ($src_addr =~ /^[:a-f0-9]+$/i) {
        my $has_dbl_colon = scalar (@{[$src_addr =~ /::/g]});
        return if $src_addr =~ /:::/ or $has_dbl_colon > 1;
        my @parts = split '::' => $src_addr;
        my @norm;

        if (@parts <= 2) {
            my @p1 = split ':' => $parts[0] if defined $parts[0];
            my @p2 = split ':' => $parts[1] if defined $parts[1];

            my $tot = @p1 + @p2;

            if ((@p1 == 8 || $has_dbl_colon) && $tot <= 8) {
                my $zeros = 8 - $tot;

                for my $part (@p1, ('0000') x $zeros, @p2) {
                    return if $part !~ /^[a-f0-9]{1,4}$/i;
                    push @norm, sprintf '%04s', lc($part); # normalize component
                }
                return join ':' => @norm;
            }
        }
    }
    return;
}

sub resembles_ip {
    return $_[0] =~ /^(?:\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|[:a-f0-9]+)$/i;
}

sub resembles_cidr {
    return $_[0] =~ /^([a-f0-9.:]+)\/\d+$/i && resembles_ip($1);
}


1;
